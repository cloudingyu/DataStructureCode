# 题目描述

有一个初始为空的序列 $A$，在题目描述中，我们用 $a_i$ 表示 $A$ 中的第 $i$ 个数字。

你需要支持以下两种操作：

1. **延申**：在序列 $A$ 的尾部添加一个数 $x$（形式化来说，假设当前 $A$ 中有 $m$ 个数，添加之后则有 $m + 1$ 个数，且 $a_{m+1} = x$）。
2. **查询**：询问当前序列 $A$ 最后的 $k$ 个数中，最大的数是多少（形式化来说，假设当前 $A$ 中有 $m$ 个数，即询问 $\max\{a_i \mid m - k + 1 \le i \le m\}$ 的值）。

为了强制你在线处理询问，输入数据进行了加密，你需要维护一个值叫 `lastans`（初始值为 0），表示上一次查询操作的答案，并且需要使用 `lastans` 来解密出真正的操作内容。具体细节可以查看输入格式。

## 输入格式

第一行，一个整数 $n$，表示操作的次数。

接下来 $n$ 行，每行输入两个加密后的整数 $a, b$。

你需要用 `lastans` 解密得到 $op, v$，规则为：

- $op = lastans \oplus a$
- $v = lastans \oplus b$

（其中 $\oplus$ 表示按位异或运算，即 C++ 的 `^` 运算符）

如果 $op = 1$，那么执行延申操作，在序列 $A$ 尾部添加一个 $v$。

如果 $op = 2$，那么执行查询操作，询问序列 $A$ 最后的 $v$ 个数中，最大的数是多少。并且你需要在求解出这个答案之后，用此答案更新 `lastans`，以确保之后的操作能够正确解密。

输入保证第一个操作一定是延申操作，且 $op = 2$ 时，$v$ 不会超过此时序列 $A$ 的长度。

## 输出格式

为了减少输出文件的大小，你并不需要按顺序输出所有询问的答案，你只需要输出一个值，表示所有询问的答案的和即可（请注意数据范围大小）。

## 样例 #1

### 样例输入 #1

```
6
1 2
1 3
1 1
2 3
1 2
3 3
```

### 样例输出 #1

```
7
```

## 数据范围与提示

### 【样例解释】

首先进行了3次延申操作，使得序列 $A = \{2, 3, 1\}$，然后第四次操作询问了后3个数中的最大值，答案应当为 3，于是第五次操作解密后是询问后1个数中的最大值，答案为 1，然后第六次操作解密后是询问后2个数中的最大值，答案应当为 3，所以最后输出 $3 + 1 + 3 = 7$。

### 【数据范围】

对于 100% 的测试数据满足 $n \le 10^6$, $1 \le op \le 2$, $1 \le v \le 10^9$。

输入保证第一个操作一定是延申操作，且 $op = 2$ 时，$v$ 不会超过此时序列 $A$ 的长度。

请注意读入数据的效率。